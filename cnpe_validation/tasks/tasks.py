import json
import zipfile
from abc import abstractmethod
from io import BytesIO

import equinox as eqx
import jax
import jax.numpy as jnp
import jax.random as jr
import requests
from cnpe.models import AbstractNumpyroGuide, AbstractNumpyroModel
from cnpe.numpyro_utils import get_sample_site_names, shape_only_trace
from jaxtyping import Array, PRNGKeyArray
from numpyro.infer import Predictive
from numpyro.util import check_model_guide_match


class AbstractTask(eqx.Module):
    """A model, guide and method for generating ground truth samples."""

    model: eqx.AbstractVar[AbstractNumpyroModel]
    guide: eqx.AbstractVar[AbstractNumpyroGuide]

    def __check_init__(self):
        model_trace = shape_only_trace(self.model)
        obs = {}
        for name in self.model.obs_names:
            if name not in model_trace:
                raise ValueError(
                    f"Trace of model does not include observed node {name}.",
                )
            obs[name] = jnp.empty(
                shape=model_trace[name]["value"].shape,
                dtype=model_trace[name]["value"].dtype,
            )  # keep runtime type checker happy

        check_model_guide_match(
            model_trace=shape_only_trace(self.model, obs=obs),
            guide_trace=shape_only_trace(self.guide, obs=obs),
        )

    def get_obs_and_latents_and_check_keys(self, key: PRNGKeyArray):
        """get_obs_and_latents and checks matches model trace and model.obs_names."""
        names = get_sample_site_names(  # TODO Inconsistent with get_obs_and_latents
            self.model.call_without_reparam,
        )

        # Not sure of implications so probably safest to error for now
        assert len(names["observed"]) == 0  # assume all obs passed as argument
        latent_names = [n for n in names["latent"] if n not in self.model.obs_names]

        obs, latents = self.get_obs_and_latents(key)

        if (mod_k := sorted(self.model.obs_names)) != (data_k := sorted(obs.keys())):
            raise ValueError(f"Model implied obs keys {mod_k}, got {data_k}")

        if latent_names != (data_k := sorted(latents.keys())):
            raise ValueError(f"Model implied latent keys {mod_k}, got {data_k}")

        model_trace = shape_only_trace(
            self.model.call_without_reparam,
        )  # Assume compatibility with guide checked elsewhere

        for data in (obs, latents):
            for name, arr in data.items():
                # TODO stricter check here?
                try:
                    trace_shape = model_trace[name]["value"].shape
                    jnp.broadcast_shapes(arr.shape, trace_shape)
                    print(f"Data {name}: {arr.shape}")
                    print(f"Trace {name}: {trace_shape}")
                except ValueError as e:
                    e.add_note(
                        f"{name} had shape {arr.shape} in data and {trace_shape} in "
                        "model trace which were incompatible.",
                    )
                    raise e

        return obs, latents

    @abstractmethod
    def get_obs_and_latents(
        self,
        key: PRNGKeyArray,
    ) -> tuple[dict[str, Array], dict[str, Array]]:
        """Get the observations and parameters.

        The parameters are from a reference posterior if available, otherwise, they are
        the ground truth parameters used to generate the observation.
        """

    @abstractmethod
    def check_obs_and_latents_match_model(self):
        pass


class AbstractTaskWithoutReference(AbstractTask):
    """A task without a reference posterior.

    The observation and parameters are generated by sampling the model.
    """

    def get_obs_and_latents(self, key):
        """Generate an observation and ground truth latents from the model."""
        # TODO Ensure always on original space?
        pred = Predictive(self.model, num_samples=1)
        key, subkey = jr.split(key)
        latents = pred(subkey)
        latents = {k: v.squeeze(0) for k, v in latents.items()}
        obs = {name: latents.pop(name) for name in self.model.obs_names}
        return obs, latents


class AbstractTaskWithReference(AbstractTask):
    """A task with a corresponding reference posterior."""


def get_posterior_db_reference_posterior(name) -> dict:
    """Get the reference posterior draws from posteriordb.

    https://github.com/stan-dev/posteriordb

    Args:
        name: The name of the zip file containing the draws, exluding the extension.
    """
    # Targetting tagged release 0.5.0 for better reproducibility
    url = f"https://github.com/stan-dev/posteriordb/raw/0.5.0/posterior_database/reference_posteriors/draws/draws/{name}.json.zip"

    # Send a GET request to the URL
    response = requests.get(url)
    response.raise_for_status()
    zip_content = BytesIO(response.content)

    # Extract the zip file
    with zipfile.ZipFile(zip_content, "r") as zip_ref:
        assert len(zip_ref.infolist()) == 1
        zip_info = zip_ref.infolist()[0]

        # Extract the JSON file from the zip
        with zip_ref.open(zip_info) as json_file:
            # Read the JSON data
            draws = json.load(json_file)

    # Concatenate the chains
    draws = {
        k: jnp.concatenate([jnp.asarray(chain[k]) for chain in draws])
        for k in draws[0].keys()
    }

    # Names may be of form param[1] param[2]. We want to stack these into an array
    stacked_draws = {k.split("[")[0]: [] for k in draws.keys()}
    for k, v in draws.items():
        key_root = k.split("[")[0]
        stacked_draws[key_root].append(v)

    return {k: jnp.stack(v, axis=-1).squeeze() for k, v in stacked_draws.items()}
